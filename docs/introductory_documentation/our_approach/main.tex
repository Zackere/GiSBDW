\section{Our approach}
\subsection{Dynamic Algorithm}
\subsubsection{Binomial Encoding~\cite{binomial_encoding}}
In this section we shall present a simple method to optimally encode $k$-element subsets of $\{0,...,n-1\}$ for $k\in\left[0;n\right]$ called binomial encoding:
\begin{lstlisting}[language=C++]
size_t Encode(Set s, size_t n, size_t k) {
	size_t ret = 0;
	while (k > 0) {
		--n;
		if (s.contains(n)) {
			ret += NChooseK(n, k);
			--k;
		}
	}
	return ret;
}

Set Decode(size_t code, size_t n, size_t k) {
  Set ret;
  while (k > 0) {
    --n;
    size_t nk = NChooseK(n, k);
    if (code >= nk) {
      ret.insert(n);
      code -= nk;
      --k;
    }
  }
  return ret;
}
\end{lstlisting}
This method of encoding is optimal beacuse it forms a bijection: $\binom{\{0,...,n-1\}}{k}\rightarrow\left[0; \binom{n}{k}\right)$.\\
It is capable of running in $O(n)$ time, provided that Pascals' Traingle is precomputed.
\subsubsection{UnionFind data structure}
UnionFind data structure is crucial in this approach. It will allow us to compute treedepth efficiently. With each set it associates some value, which will be managed by UnionFind data structure internally. Our implementation shall satisfy following contract:
\begin{itemize}
	\item It can be constructed from integer $n$. As a result, we get a UnionFind data structure representing $n$ disjont one-element subsets of $\{0,...,n-1\}$ and has associated value equal to 1. Each set has an id equal to the element it contains.
	\item \texttt{UnionFind Clone()} clones given object.
	\item \texttt{ValueType GetValue(SetIdType)} returns value associated with given set.
	\item \texttt{ValueType GetMaxValue()} returns maximum of all values associated with sets represented by the object.
	\item \texttt{SetIdType Find(ElemType)} returns id of a set in which given element is contained.
	\item \texttt{SetIdType Union(SetIdType s1, SetIdType s2)} sums two given sets. As a result of this operation:
	\begin{itemize}
		\item \texttt{s1} will not change its id.
		\item Every element of \texttt{s2} will be contained in \texttt{s1}.
		\item Value associated with \texttt{s1} is replaced with \\ the greatest of values: \texttt{GetValue(s1)}, \texttt{GetValue(s2) + 1}
	\end{itemize}
\end{itemize}
The data structure difined this way allows to compute treedepth very efficiently, as values associated with contained sets change in the same way as treedepth if we were to attach one tree to the root of another tree. Complexity of each operation is not much bigger than $O(1)$ (if not exactly $O(1)$) except for construction and copying which have $O(n)$ time complexity.
\subsubsection{Idea behind the algorithm}
Having described all necessary tools, we shall now proceed to describe dynamic approach to computing treedepth value as well as treedepth decomposition. As mentioned earlier, this method trades off space complexity of $O\left(2^{\left|G\right|}\cdot\left|G\right|\right)$ for time complexity of  $O^{*}\left(2^{\left|G\right|}\right)$.
The algorithm builds the treedepth decomposition in bottom-to-top manner. It generates an array of pairs \texttt{(UnionFind, size\_t)} from another array of the same type. We start off with an array of one element: unmodified UnionFind constructed from $\left|G\right|$ and 0. Then, given a UnionFind object, for every inactive vertex $v$ in it we shall generate a new one by:
\begin{itemize}
	\item activating vertex in question
	\item performing \texttt{Union(Find($v$), Find($w$))} for every active neighbour $w$ of $v$ in $G$
\end{itemize}
This very action adds vertex $v$ to some treedepth decomposition of $G$ induced on set of active vertices.\\
At this point it would be appropriate to explain what an active vertex is and how we will handle them. It is a concept which tells us whether a vertex is in a solution represented by given UnionFind object. With an index in an array we associate a UnionFind object. This index shall be decoded into a subset of $\{0,...,n-1\}$ which will tell us what vertices are active in object in question (nevertheless nothing stops us from accessing other elements).\\
Having generated a new UnionFind we shall store it in output array under the index equal to encoding of a set of active vertices contained in generated UnionFind object. With it we store an index from which we recieved the original UnionFind object. It will be useful in treedepth decomposition reconstruction. If there is some UnionFind object in the designated space, we replace the object in it only if our UnionFind has lower max value.
\subsubsection{The Algorithm}
\begin{lstlisting}[language=C++]
void TDDynamicStep(Graph g, size_t step_number, (UnionFind, size_t)[] prev, (UnionFind, size_t)[] next) {
  for(size_t subset_index = 0; subset_index < prev.size(); ++subset_index) {
    // Get set of active vertices
    Set s = Decode(subset_index, V(g).size(), step_number);
    for(ElemType x : V(g)\s) {
      UnionFind uf_x = prev[subset_index].first.Clone();
      Set ids = {};
      // Find trees containing neighbours of v
      for(ElemType v : g.neigh(x))
        if(s.contains(v))
          ids.insert(uf_x.Find(v));
      SetIdType new_set_id = uf_x.Find(x);
      // Ensure that we are still in compliance with treedepth decomposition definition when adding x to active vertices
      for(SetIdType id : ids)
        new_set_id = uf_x.Union(new_set_id, id)
      s.insert(x);
      // Determine designated index of our new object
      size_t dest = Encode(s, V(g).size(), step_number + 1);
      // Check if we have improved current result for combination of active vertices represented by s
      if(next[dest] == null || next[dest].first.GetMaxValue() > uf_x.GetMaxValue())
        next[dest] = (uf_x, subset_index)
    }
  }
}

(UnionFind, size_t)[][] TDDynamicAlgorithm(Graph g) {
  // Base of the algorithm: object representing empty set of active vertices
  (UnionFind, size_t)[][] history = new (UnionFind, size_t)[V(g).size()][];
  history[0] = new (UnionFind, size_t)[1];
  history[0][0] = UnionFind(V(g).size());
  for(size_t i = 0; i < V(g).size(); ++i) {
    history[i + 1] = new (UnionFind, size_t)[NChooseK(V(g).size(), i + 1)];
    TDDynamicStep(g, i, history[i], history[i + 1]);
  }
  return history;
}
\end{lstlisting}
Having completed the dynamic algorithm, the object on the last page of history holds the treedepth of our graph. Based on the history we can reconstruct the treedepth decomposition in $O(|G|)$ time:
\begin{lstlisting}[language=C++]
(Graph, int) TDDecomposition(Graph g, (UnionFind, size_t)[][]history) {
  size_t current_entry = 0, current_page = V(g).size() - 1;
  int depth = history[current_page][current_entry].second;
  // This list will hold permutation of vertices that made up the object in history[current_page][current_entry]
  List indices = {current_entry};
  while(current_page > 0) {
    indices.push_front(history[current_page][current_entry].second);
    current_entry = history[current_page][current_entry].second;
    --current_page;
  }
  Graph tree(V(g).size());
  while(current_page < V(g).size()) {
    size_t current_entry = indices.pop_front();
    Set s = Decode(current_entry, V(g).size(), current_page);
    // Find vertex that had beed added in considered transition
    ElemType v = Decode(indices.front(), V(g).size(), current_page)\s;
    UnionFind uf = history[current_page][current_entry].first;
    // Add edges required by the definition of treedepth decomposistion
    for(ElemType w : g.neigh(v))
      if(s.contains(w))
        tree.add_edge(v, uf.Find(w));
    ++current_page;
  }
  return tree, depth;
}
\end{lstlisting}
This algorithm finds what vertices have been added on consequent steps and joins appropriate trees under common parent vertex.
\subsubsection{Remarks}
As we can see, this algorithm provides an obvious improvement in time complexity of $O^{*}\left(2^{\left|G\right|}\right)$ compared to naive approach with time complexity of $O\left(\left|G\right|!\right)$, but it requires additional $O\left(2^{\left|G\right|}\cdot\left|G\right|\right)$ space to run. It is particularly important for set encoding to be very efficient as it will be executed many times, therefore presented method for such encoding might not make it into final implementation and be replaced with different method or be modified significantly. So much space is necessary by this algorithm to run, that it can be too much for large graphs. We will try to overcome this difficulty later. It also has some useful properties which we will exploit, but this will be also discussed later.
\subsection{Branch and Bound algorithm}
In contrary to dynamic algorithm, this time we will try to build treedepth decomposition in top-to-bottom manner. To make this approach efficient, we shall incorporate branch and bound technique. Please note that this approach assumes connected input graph. This assumption is valid as for disconnected graphs we can run this algorithm for every connected component.
\subsubsection{Idea behind the algorithm}
As in every branch and bound algorithm, we shall start with some valid solution to our problem. We can try to find some good heuristic solution, but for now $P_{\left|G\right|}$ will be sufficient. Along this solution we must store its treedepth of $\left|G\right|$ as we will improve this number and eliminate some unnecessary attempts. We can now proceed to generating our solutions. First, we will choose a root of our tree. Then, we will choose its children. Then we will choose their children and so on. We will be building our solution generation after generation (like generations of a family). When chosen generation is too deep in our tree, we terminate current attempt and try different configuration.
\subsubsection{Determining which vertices are valid as children}
Not every vertex will be suitable as a child of another vertex in treedepth decomposition. Take as an example $P_5$ and its decomposition generation. Let's say that we chose as a root of our tree vertex 2. Then we know, for sure, that vertices 1 and 3, as neighbours of 2, must be in a subtree of 2. Let's say that we decided, that 1 and 3 will be the only children of 2. Now we know for sure, that vertex 0 must be in a subtree of 1 and vertex 4 must be in a subtree of 3. A tree when vertex 0 is a child of vertex 3 will not be valid treedepth decomposition.\\
General rule is: every neghbour of $v$ in $G$ must be either its child or ancestor in a valid treedepth decomposition (as definition of treedepth decomposition states).\\
During execution of branch and bound algorithm we will keep track of preferences (in subtree of which vertex it must be placed) of each vertex along with information about what vertices are already in the tree.
\subsubsection{The Algorithm}
\begin{lstlisting}[language=C++]
// Global variables used by the algorithm (Current state)
const int Taken = -1;
const Graph g = GetConnectedGraph();
int[] preference = new int[V(g).size()];
Graph best_tree = Path(V(g));
int best_td = V(g).size();
Graph current_tree = Graph();

// Finds treedepth decomposition with its treedepth using branch and bound technique
(Graph, int) TDBnB() {
  for(int root = 0; root < V(g).size(); ++root) {
    // Vertices which will have its children generated next. Right now it's just root.
    Set active_vertices = {root}
    for(int y = 0; y < V(g).size(); ++y)
      // Every vertex will end up in a subtree of trees' root.
      preference[y] = root;
    current_tree = Graph();
    current_tree.add_vertex(root);
    preference[root] = Taken;
    NextLevel(1, active_vertices);
  }
  return best_tree, best_td;
}

// This function is called whenever we have finished generating a level in current_tree. active_vertices is a set of vertices which will have its children chosen next. Depth tells us how deep finished level is. It checks whether we have a chance improving previous results and starts generation of next level.
Collision NextLevel(int depth, Set active_vertices) {
  if(V(current_tree).size() == V(g).size() && depth < best_td) {
    (best_tree, best_td) = (current_tree, depth)
    return null
  }
  if(active_vertices.empty() || depth + 1 >= best_td)
    return null;
  return GenerateFrom(depth + 1, active_vertices, {}, 0);
}

// Tries to add child to active_vertices_new as a child of parent and update both current_tree and history. When it contradics with treedepth decomposition definition, it returns an error and makes no changes to current state.
Collision TryVertexAsAChild(int child, int parent) {
 ...
 return collision;
}

// Determines whether given collision makes current state contradictory with treedepth decomposition definition
bool Critical(Collision collision) {
  ...
  return false;
}

// This function considers vertex from as a child of consecutive vertices from active_vertices. At the time of calling this function, every vertex v < from has been considered on this level to some extent. Note that calling this function does not change current state i.e. after this function returns state is how it was before the call.
Collision GenerateFrom(int depth, Set active_vertices, Set active_vertices_new, int from) {
  if(history[from] != Taken) {
    for(int x : active_vertices) {
      // Dump all information that might change as a result of TryVertexAsAChild
      State previous_state = CurrentState.save();
      Collision collision = TryVertexAsAChild(from , x);
      if(collision == null) {
        State current_state = CurrentState.save();
        if(from + 1 < V(g).size()) {
          // Try continuing generation from next vertex
          collision = GenerateFrom(depth, active_vertices, active_vertices_new, from + 1);
          // Rollback changes made
          previous_state.apply();
          if(Critical(collision))
            return collision;
         current_state.apply();
        }
        // Try finishing generating this level
        collision = NextLevel(depth, active_vertices_new);
        // Rollback changes made
        previous_state.apply();
        if(Critical(collision))
          return collision;
      }
      else if(Critical(collision))
        return collision;
    }
  }
  // Try not adding from as a child of any vertex on this level
  if(from + 1 < V(g).size())
    return GenerateFrom(depth, active_vertices, active_vertices_new, from + 1);
  return NextLevel(depth, active_vertices_new);
}
\end{lstlisting}
\subsubsection{Remarks}
Despite very high pesymistic time complexity being at most $O^*\left(\left|G\right|^{\left|G\right|-2}\right)$ it is expected for this algorithm to perform reasonably well, just as TSP algorithm using branch and bound technique~\cite{tsp_bnb} does. With every improvement of initial heuristic this algorithm will significantly reduce its running time. It has small space complexity of $O\left(\left|G\right|^2\right)$ which is much better than dynamic algorithms' space complexity of $O\left(2^{\left|G\right|}\cdot\left|G\right|\right)$. The depth of recursion of this algorithm is at most $2\cdot\left|G\right|$ which is small enough to not worry about stack overflow when implementing it on a standard machine.
