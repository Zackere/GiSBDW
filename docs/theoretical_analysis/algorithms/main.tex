\section{Implemented Algorithms}
\subsection{Elimination Tree Data Structure}
Elimination Tree proved to be a central figure in many of algorithms that we implemented. It is an implementation of Treedepth decomposition of incomplete elimination defined in introductory documentation, thus we will mention it briefly here:
\begin{enumerate}
	\item Treedepth decomposition of incomplete elimination $w$ is a rooted tree $T_w$ such that:
\begin{itemize}
	\item Treedepth decomposition of empty elimination (empty word $\varepsilon$) is a single vertex represented by $G$.
	\item Treedeph decomposition of incomplete elimination $wv$, is built from $T_w$, in the following way:
	\begin{enumerate}
		\item Find leaf $H$ in $T_w$ such that $v\in H$.
		\item Add every connected component of $H-v$ as a child of $H$.
		\item Replace node $H$ with $v$.
	\end{enumerate}
\end{itemize}
\item Depth of a node $v$ in $T_w$ is defined as a length of a path between $T_w$ root and $v$ and is denoted as $depth_{T_w}\left(v\right)$.
\end{enumerate}
Its implementation can be found in \texttt{elimination\_tree.hpp}.
\subsection{Heuristics}
\subsubsection{Highest Degree Heuristic}
\subsubsection{Variance Heuristic}
\subsubsection{Bottom-Up Heuristic}
This approach trades off space complexity of $O^*\left(2^n\right)$ for time complexity of  $O^*\left(2^n\right)$ and fairly good approximations. We shall incorporate a Union-Find data structure to represent components of induced subgraph. We will add one vertex at a time to every known induced subgraph. We distinguish induced subgraphs by their depth, and keep ones that have it the smallest. This algorithm does not produce exact solutions, as much as we would hope it did, beacuse we do not optimize choice of vertex for components which this vertex would connect. We do not know how bad of an approximation this algorithm can produce (probably as bad as it gets), but for as long as we had memory to keep it running it was not far off from the optimal solutions. We implemented it on a GPU and its implementation can be found in \texttt{bottom\_up\_heuristic\_gpu\_algorithm.hpp}.
\subsubsection{Formula for lower bound}
We have discovered a function which for given graph $G=(V,E)$ tells us what is a minimum treedepth value for this graph:

\begin{gather*}
f(n,e)=\Bigl\lceil\frac{1}{2}+n-\sqrt{\frac{1}{4}-n+n^2-2e}   \,\Bigr\rceil, \\
\text{where $n = |V|$, $e = |E|$}
\end{gather*}


Here is our thought process.
Let us look at this problem from opposite direction. Given a particular treedepth decomposition, we can create from it all graphs for which this decomposition will be valid. This is pictured on the figure below. As we can see, the treedepth decomposition on the left is a valid decomposition for any graph which has some of the edges shown on the right as a dotted lines. Or in other words: is a valid decomposition for graph on the right and all graphs induced by it.
\begin{center}
	\includegraphics[width=\textwidth]{transform.png}
\end{center}
Here we can notice an important thing: a vertex on level $k$ adds $k-1$ edges that input graph can possibly have. In this example, vertex 3 creates two additional edges that a potential input graph can have: edge 3-0 and 3-2, while vertex 2 - being on level 2 - creates only one additional edge (2-0).\\
Knowing this we can ask ourselves a question: having a fixed treedepth value $td$ and fixed number of vertices $n$, what the structure of treedepth decomposition that maximizes number of possible edges in input graph looks like?\\
Let us carry out the following construction. We start with $n$ vertices and no edges.
At the beggining we do not have any choice as we have to ensure that $td$ equals given value, so we construct $P_{td}$ path. Now we are still left with $n-td$ vertices - where should we attatch them to maximize the number of possible edges in input graph? As we have said earlier: a vertex on level $k$ adds $k-1$ edges that input graph can possibly have. From this we conclude that we have to attatch in such a way that they will be on the lowest possible level which in our case is $k=td$. Below is an example for $td=3$ and $n=5$.
\begin{center}
	\includegraphics[width=\textwidth]{construction.png}
\end{center}
From all treedepth decompositions with fixed $td$ and $n$, this one supports the highest possible number of edges in input graph. This decomposition supports maximally up to
$$\sum\limits_{i=1}^{td-1} i + (n-td)(td-1)$$edges. The sum part of equation corresponds to the $P_{td}$ path and rest of the equation takes for account the vertices which we attach at the lowest level.\\
Finally, solving this equation for $td$ leaves us with formula presented at the beggining.
\subsection{Exact Algorithms}
\subsubsection{Iterative Dynamic}
\subsubsection{Recursive Dynamic}
In contrary to iterative dynamic algorithm, we shall calculate treedepth of a graph straight from definition of treedepth:
\begin{equation}
td(G)={\begin{cases}1,&{\text{if }}|G|=1;\\1+\min _{{v\in V}}td(G-v),&{\text{if }}G{\text{ is connected and }}|G|>1;\\\max _{{i}}td(G_{i}),&{\text{otherwise}};\end{cases}}
\end{equation}
It shares some features with a iterative approach:
\begin{enumerate}
	\item Whenever we successfully calculated treedepth of a graph, we save that information for later to avoid repeating calculations
	\item We keep treedepth information only about connected graphs
\end{enumerate}
On the other hand this approach enables some optimizations which are not suitable for iterative approach:
\begin{enumerate}
	\item Graph encoding can be changed for faster binary encoding since we do not rely on optimality of set encoding
	\item Elimination Tree data structure is used to detect connected components of induced subgraph which avoids recalculation of such components and is more efficient overall
\end{enumerate}
Sadly, binary encoding limits number of vertices of a graph to be processed. Currently it is set to 128 but easily expandable to up to 1024.\\
Implementation of this algorithm can be found in \texttt{dynamic\_cpu\_improv.hpp}.
\subsubsection{Raw Branch and Bound}
This algorithm is a fairly straight-forward branch and bound algorithm, but includes few problem-specific optimizations. It uses Eliimnation Tree data structure in order to keep track of components yet to be eliminated. Differences from standard B\&B include:
\begin{enumerate}
	\item Elimination order of vertices from different components is not differentiated. This results in every set of components to be eliminated to be considered exactly once
	\item When elimination order of some component is known, it is eliminated immediately
	\item Lower bounds are calculated for every connected component independently
\end{enumerate}
And their significance:
\begin{enumerate}
	\item This modification granted us massive increase in performance basically for free due to an easy access to each connected component
	\item This modification is yet to be tested
	\item This modification simplified implementation of lower bound algorithms and allows us to tell quicker whether a branch should be pruned. It also allows us for some parallelism but it is yet to be implemented
\end{enumerate}
Overall performance of this algorithm shall be discussed later. Implementation of this algorithm can be found in \texttt{branch\_and\_bound.hpp}.
\subsubsection{Branch and Bound with Cache}
